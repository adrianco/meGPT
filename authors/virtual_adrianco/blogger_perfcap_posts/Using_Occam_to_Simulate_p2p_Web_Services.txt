Title: Using Occam to Simulate p2p Web Services
URL: https://perfcap.blogspot.com/2007/06/using-occam-to-simulate-p2p-web.html

<p>About a year ago I gave a paper at an IEEE E-Commerce conference that described how I used the latest pi-calculus enhanced version of the old Inmos Transputer language Occam to build a very efficient massively threaded simulator for large scale p2p web services that ran on my laptop.</p> <p><!-- PProtector --><a href="http://perfcap.blogspot.com/2006/07/ieee-conference-paper.html">I blogged this at the time</a>, but The paper itself is subject to the rules IEEE sets out for peer-reviewed conference papers and you need to be a member or pay a fee to get it from <a href="http://doi.ieeecomputersociety.org/10.1109/CEC-EEE.2006.81">http://doi.ieeecomputersociety.org/10.1109/CEC-EEE.2006.81</a></p> <p>However, I wanted to share this more widely and have just posted a <a href="http://web.mac.com/adriancockcroft/Public/SkypeSim07.pdf">pdf of the presentation slides for my IEEE paper</a>. Here are the first few slides, and a description of the Tools section:</p> <p><b>Simulation of Skype Peer-to-peer Web Services Choreography Using Occam-Pi</b><br /></p> <p><!-- PProtector --><b>Abstract</b><br />Complex web services are very difficult to test and verify before deployment on a large scale.<br />A semantically equivalent in-memory simulation can be built using Occam-pi that runs up to 100,000 nodes about a million times faster than real life.<br />Rapid protocol development and detailed behavioral analysis using simulation supports the development of robust services that can scale.<br />The implementation of a simulator that models centralized web services and application to application messaging over the Skype Peer to Peer network is described.</p> <p><b>Overview</b><br /></p> <ul><li>The Landscape</li><li>The Problem</li><li>The Tools</li><li>The Solution</li><li>Implementation</li><li>Running the Simulation</li><li>Conclusion</li><li>References</li></ul> <p><!-- PProtector --><b>The Tools</b> – Pi Calculus<br /></p> <ul><li>WS-BPEL, SSDL and WS-CDL are based on Pi-Calculus</li><li>Pi-Calculus is based on Communicating Sequential Processes (CSP)</li><li>Pi-Calculus provides a formal model of parallel message based computing</li><li>Occam-Pi</li><li>The Occam language is based on CSP, and has been extended to add the Pi-Calculus extensions to form the Occam-Pi language.</li><li>The primary implementation of this language is known as KROC, the Kent Re-targetable Occam Compiler</li><li>KROC is freely available from the University of Kent at Canterbury, UK</li><li>Runs on Intel architecture Linux, MacOS X, and Microsoft Windows/Cygwin platforms. Older versions exist for SPARC, PPC etc.</li></ul> <p><b>The Tools</b> – Occam Language Constructs<br /></p> <ul><li>The constructs that are used in Web Services choreography map directly to Occam language constructs</li><li>The Occam language has direct support for sequential, parallel and alternate processing blocks, complex protocols, and channel based communications</li><li>Occam-Pi adds more dynamic constructs to the language</li><li>Mobile channels - pass a channel end over another channel</li><li>Mobile processes - suspend a process, pass it over a channel and resume it in a new context</li><li>Dynamic process forking with barrier synchronization</li><li>Rigorous Occam-Pi Compile-time Checks</li><li>Processes or expressions are not allowed to have any “side effects”</li><li>Syntax and usage of all protocols, data and constructs is checked</li><li>Occam is designed to allow very comprehensive static analysis</li></ul>  <p><b>The Tools</b> – Occam Runtime Characteristics<br /></p> <ul><li>There is no need to use XML message encoding or namespaces</li><li>since the compiler can check that a protocol is being communicated correctly</li><li>At runtime, the Occam-Pi language is fast small compiled code</li><li>with its own threading model, in a single process</li><li>The Occam-Pi runtime detects and reports deadlock</li><li>including the line number in the code at which each process was stalled</li><li>Occam-Pi is very efficient</li><li>All communication takes place in a single address space at memory bus speeds</li><li>Basic process creation takes 20 nanoseconds on an 800MHz PC</li><li>Basic channel communications takes 70 nanoseconds</li><li>Compared to typical web services transactions over the internet these transactions are about a million times faster</li><li>The language is also very compact, and one hundred thousand to one million threads can be created within a 2 GByte address space.</li></ul><span style="font-weight: bold;">Works Cited</span><br /><ul><li>[Cygwin] “GNU + Cygnus + Windows”, <a href="http://www.cygwin.com/">http://www.cygwin.com/</a></li><li>[GraphML] “Graph Modeling Language “, <a href="http://graphml.graphdrawing.org/">http://graphml.graphdrawing.org/</a></li><li>[Hoare78] C. A. R. Hoare. “Communicating Sequential Processes.” Communications of the ACM 1978.</li><li>[Hoare85] C. A. R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.</li><li>[KROC]. “Kent Retargetable Occam Compiler”  <a href="http://www.cs.kent.ac.uk/projects/ofa/kroc/">http://www.cs.kent.ac.uk/projects/ofa/kroc/</a></li><li>[Occam2] Inmos Ltd, Occam 2 Reference Manual. Prentice Hall, 1988.</li><li>[Milner99] Robin Milner, “Communicating and Mobile Systems: the Pi-Calculus”, Cambridge University Press, 1999.</li><li>[Skype]. “Skype Developers API”  <a href="https://developer.skype.com">https://developer.skype.com</a></li><li>[SSDL] Webber et al. “Asynchronous Messaging between Web Services using SSDL.” IEEE Internet Computing Vol10, No1 2006.</li><li>[WS-BPEL]. “OASIS Web Services Business Process Execution Language”  <a href="http://www.oasis-open.org">http://www.oasis-open.org</a></li><li>[WS-CDL] “Web Services Choreography Description Language”, <a href="http://www.w3.org">http://www.w3.org</a></li><li>[yEd] “Graph visualization and editing tool”, <a href="http://www.yworks.com/">http://www.yworks.com/</a></li></ul>