Title: Cockcroft Headroom Plot - Part 2 - R Version
URL: https://perfcap.blogspot.com/2006/11/cockcroft-headroom-plot-part-2-r.html

I kept tweaking the code, and came up with a prettier version, that also has a small time series view of the throughput in the top right corner.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://photos1.blogger.com/x/blogger2/3864/907/1600/207207/chp.gif"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://photos1.blogger.com/x/blogger2/3864/907/400/212741/chp.png" border="0" alt="" /></a><br /><br />The code for this is<br /><pre><br />chp <- function(x,y,xl="Throughput",yl="Response",tl="Throughput Time Series", ml="Cockcroft Headroom Plot") {<br />       xhist <- hist(x,plot=FALSE)<br />       yhist <- hist(y, plot=FALSE)<br />       xrange <- c(0,max(x))<br />       yrange <- c(0,max(y))<br />       nf <- layout(matrix(c(2,4,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)<br />       layout.show(nf)<br />       par(mar=c(5,4,0,0))<br />       plot(x, y, xlim=xrange, ylim=yrange, xlab=xl, ylab=yl)<br />       par(mar=c(0,4,3,0))<br />       barplot(xhist$counts, axes=FALSE, ylim=c(0, max(xhist$counts)), space=0, main=ml)<br />       par(mar=c(5,0,0,1))<br />       barplot(yhist$counts, axes=FALSE, xlim=c(0,max(yhist$counts)), space=0, horiz=TRUE)<br />       par(mar=c(2.5,1.5,3,1))<br />       plot(x, main=tl, cex.axis=0.8, cex.main=0.8, type="S")<br />}<br /></pre><br /><br />I also made a wrapper function that steps through the data over time in chunks.<br /><pre><br />> chp.step <- function(x, y, steps=10, secs=1.0) {<br />    xl <- length(x)<br />    step <- xl/steps<br />    for(n in 0:(steps-1)) {<br />        Sys.sleep(secs)<br />        chp(x[(1+n*step):min((n+1)*step,xl)],y[(1+n*step):min((n+1)*step,xl)])<br />    }<br />}<br /></pre><br /><br />To run this smoothly on windows, I had to disable double buffering using<br /><pre><br />> options("windowsBuffered"=FALSE)<br /></pre><br />and close the graphics window so that a new one opens with the new option.<br /><br />The data is displayed using the same calls as described in Part 1. The next step is to try some different data sets and work on detecting saturation automatically.