Title: Enhanced headroom plot in R
URL: https://perfcap.blogspot.com/2008/07/enhanced-headroom-plot-in-r.html

For some reason I seem to find time to <a href="http://www.r-project.org">write code in R</a> when I'm on an airplane. The last two trips I made resulted in significant enhancements and debugging of the code for my headroom plot. <a href="http://perfcap.blogspot.com/search?q=chp">It started off simple</a> but it now has a lot of bells and whistles, including color coding.<br /><br />Main changes: the quantile used to remove outliers now only removes outliers that exceed the 95th percentile response time by default. It keeps all the throughput values unless you use qx=True.<br /><br />In each of the throughput bins used to draw the histogram, the maximum response time for that bin is now calculated and displayed as a staircase line unless you set max=False.<br /><br />The set of data is now split into ranges and color coded. The times series plot is coded so you can see the split, and the scatterplot shows how those points fall. I have been plotting weekly data at one minute intervals with split=7, which looks pretty good.<br /><br />I read in some data that has been extracted from vxstat into a csv format at a known URL and plotted it three ways.<br />I plot the first 2880 data points, picking the read data rather than write, two days at one minute intervals.<br /><br /><pre><br />> stime <- read.csv(url("http://somewhere/vxstat_response"))<br />> sops <- read.csv(url("http://somewhere/vxstat_throughput"))<br /><br />> names(sops)<br />[1] "DateTime"                             "vxstat_dg_operationsRead" <br />[3] "vxstat_dg_operationsWrite"<br /><br />> chp(sops[1:2880,2],stime[1:2880,2])<br />> chp(sops[1:2880,2],stime[1:2880,2],q=1.0)<br />> chp(sops[1:2880,2],stime[1:2880,2],q=1.0,splits=8)<br /></pre><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicozweOijXAXOq_MGRl-Eu_G0Vq0mcTa7ghReBBq8p2XfxMbcMPxBqRwETJydJxDFoDjhNO0xlCSxHRnKyPvTlR9EL2FmJ29lrrNAESD8Ig3UB_y2VW60b0P4Cg3pagq69EWd2/s1600-h/chpblog1.png"><img style="cursor:pointer; cursor:hand;" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicozweOijXAXOq_MGRl-Eu_G0Vq0mcTa7ghReBBq8p2XfxMbcMPxBqRwETJydJxDFoDjhNO0xlCSxHRnKyPvTlR9EL2FmJ29lrrNAESD8Ig3UB_y2VW60b0P4Cg3pagq69EWd2/s400/chpblog1.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5223131801032379890" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjZa6eSR5LHNTdICbiuccSetn66WRiFZbpN9t2Kk63-zmzWfge7r99NKHGVdnGvY5HT0FsAdEZtPUH33RQ0UHRZ1d7cLkGcNrre4po9q5lg4rH93PfnmKvzZINPk72gNkNPrsgx/s1600-h/chpblog2.png"><img style="cursor:pointer; cursor:hand;" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjZa6eSR5LHNTdICbiuccSetn66WRiFZbpN9t2Kk63-zmzWfge7r99NKHGVdnGvY5HT0FsAdEZtPUH33RQ0UHRZ1d7cLkGcNrre4po9q5lg4rH93PfnmKvzZINPk72gNkNPrsgx/s400/chpblog2.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5223131991156304722" /></a><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj8Yib6ijtSlSmUkOahFuIjwzPT06rBN5S-q1c-dCE4YLZMn8jJLQotrMlC8K-E1Fg6i0VZwbzFDxShoTAKv7DtJ_q-xUsaNVd6oUtX7PqEDuE8zqCp6TDv8tkyd8O70-4G17kn/s1600-h/chpblog3.png"><img style="cursor:pointer; cursor:hand;" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj8Yib6ijtSlSmUkOahFuIjwzPT06rBN5S-q1c-dCE4YLZMn8jJLQotrMlC8K-E1Fg6i0VZwbzFDxShoTAKv7DtJ_q-xUsaNVd6oUtX7PqEDuE8zqCp6TDv8tkyd8O70-4G17kn/s400/chpblog3.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5223132131633288482" /></a><br /><br /><br /><br />Here is the code that generates the plot.<br /><br /><pre><br />> chp <-function(throughput,response, q=0.95, qx=F, xl="Throughput",yl="Response",tl="Throughput Over Time",<br />ml="Headroom Plot", fit=T, max=T, splits=0) {<br />      # remove zero throughput and response values<br />      nonzer <- (throughput != 0) & (response != 0)  # array of true/false<br />      y <- response[nonzer]<br />      x <- throughput[nonzer]<br />      # remove outliers, keep response time points inside 95% by default<br />      if (q != 1.0) {<br />              quant <- (y < quantile(y,q))<br />              # optionally trim throughput outliers as well<br />              if (qx) quant <- quant & (x < quantile(x, q))<br />              x <- x[quant]<br />              y <- y[quant]<br />      }<br />      # make histograms and record end points for scaling<br />      xhist <- hist(x,plot=FALSE)<br />      yhist <- hist(y,plot=FALSE)<br />      xbf <- xhist$breaks[1]                          # first<br />      ybf <- yhist$breaks[1]                          # first<br />      xbl <- xhist$breaks[length(xhist$breaks)]       # last<br />      ybl <- yhist$breaks[length(yhist$breaks)]       # last<br />      xcl <- length(xhist$counts)                     # count length<br />      ycl <- length(yhist$counts)                     # count length<br />      xrange <- c(0.0,xbl)<br />      yrange <- c(0.0,ybl)<br />      xlen <- length(x)<br />      # make a multi-region layout<br />      nf <- layout(matrix(c(1,3,4,2),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)<br />      layout.show(nf)<br />      # set plot margins for throughput histogram and plot it<br />      par(mar=c(0,4,3,0))<br />      barplot(xhist$counts, axes=FALSE,<br />              xlim=c(xcl*0.00-xbf/((xbl-xbf)/(xcl-0.5)),xcl*1.00),<br />              ylim=c(0, max(xhist$counts)), space=0, main=ml)<br />      # set plot margins for response histogram and plot it sideways<br />      par(mar=c(5,0,0,1))<br />      barplot(yhist$counts, axes=FALSE, xlim=c(0,max(yhist$counts)),<br />              ylim=c(ycl*0.00-ybf/((ybl-ybf)/(ycl-0.5)),ycl*1.00),<br />              space=0, horiz=TRUE)<br />      # set plot margins for time series plot<br />      par(mar=c(2.5,1.7,3,1))<br />      plot(x, main=tl, cex.axis=0.8, cex.main=0.8, type="S")<br />      if (splits > 0) {<br />   step <- xlen/splits<br />   for(n in 0:(splits-1)) {<br />    lines((1+n*step):min((n+1)*step,xlen), x[(1+n*step):min((n+1)*step,xlen)], col=4+n)<br />   }<br />      }<br />      # set plot margins for main plot area<br />      par(mar=c(5,4,0,0))<br />      plot(x, y, xlim=xrange, ylim=yrange, xlab=xl, ylab=yl, pch=20)<br />      if (max) {<br />        # max curve<br />        b <- xhist$breaks<br />        i <- b[2] - b[1] # interval<br />        maxl <- list(y[b[1] < x & x <= (b[1]+i)])<br />        for(n in b[c(-1,-length(b))]) maxl <- c(maxl,list(y[n < x & x <= (n+i)]))<br />        #print(maxl)<br />        maxv <- unlist(lapply(maxl,max)) # apply max function to elements of list<br />        #print(maxv)<br />        #lines(xhist$mids,maxv,col=2)  # join the dots<br />        #staircase plot showing the range for each max response<br />        lines(rep(b,1,each=2)[2:(2*length(maxv)+1)],rep(maxv,1,each=2),col=3)<br />        <br />      }<br />      if (fit) {<br />        # fit curve, weighted to predict high throughput<br />        # create persistent chpfit object using <<-<br />        chpfit <- glm(y ~ x, inverse.gaussian, weights=as.numeric(x))<br />        # add fitted values to plot, sorted by throughput<br />        lines(x[order(x)],chpfit$fitted.values[order(x)],col=2)<br />      }<br />      if (splits > 0) {<br />   step <- xlen/splits<br />   for(n in 0:(splits-1)) {<br />    Sys.sleep(1)<br />    points(x[(1+n*step):min((n+1)*step,xlen)],y[(1+n*step):min((n+1)*step,xlen)], xlim=xrange, ylim=yrange, col=4+n)<br />   }<br />      }<br />}<br /></pre>