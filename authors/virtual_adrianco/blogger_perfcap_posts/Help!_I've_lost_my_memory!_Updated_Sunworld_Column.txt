Title: Help! I've lost my memory! Updated Sunworld Column
URL: https://perfcap.blogspot.com/2005/10/help-ive-lost-my-memory-updated.html

<p><span style="font-size:78%;"><span style="font-family:verdana, arial, geneva, sans-serif;">Originally published in Unix Insider 10/1/95 <span style="color:#dc2300;"><br />Stripped of adverts, url references fixed and comments added in red type to bring it up to date ten years later.</span></span></span></p><p><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">Dear Adrian, After a reboot I saw that most of my computer's memory was<br />free, but when I launched my application it used up almost all the<br />memory. When I stopped the application the memory didn't come back!<br />Take a look at my <code><span style="font-family:courier;">vmstat</span></code><em> </em></span></span>output:<span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;"> </span></span><br /></p><pre><span style="font-family:courier;"><span style="font-size:85%;">% vmstat 5</span></span><br /><span style="font-family:courier;">procs     memory            page            disk          faults      cpu</span><br /><span style="font-family:courier;">r b w   swap  free  re  mf pi po fr de sr s0 s1 s2 s3   in   sy   cs us sy id</span><br /></pre><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><em>This is before the program starts:</em></span></span></p><pre><span style="font-family:courier;">0 0 0 330252 80708   0   2  0  0  0  0  0  0  0  0  1   18  107  113  0  1 99</span><br /><span style="font-family:courier;">0 0 0 330252 80708   0   0  0  0  0  0  0  0  0  0  0   14   87   78  0  0 99</span><br /></pre><p><em><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">I start the program and it runs like this for a while:</span></span></em></p><pre><span style="font-family:courier;">0 0 0 314204  8824   0   0  0  0  0  0  0  0  0  0  0  414  132   79 24  1 74</span><br /><span style="font-family:courier;">0 0 0 314204  8824   0   0  0  0  0  0  0  0  0  0  0  411   99   66 25  1 74</span><br /></pre><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><em>I stop it, then almost all the swap space comes back, but the free memory does not:</em></span></span></p><pre><span style="font-family:courier;">0 0 0 326776 21260   0   3  0  0  0  0  0  0  1  0  0  420  116   82  4  2 95</span><br /><span style="font-family:courier;">0 0 0 329924 24396   0   0  0  0  0  0  0  0  0  0  0  414   82   77  0  0 100</span><br /><span style="font-family:courier;">0 0 0 329924 24396   0   0  0  0  0  0  0  0  2  0  1  430   90   84  0  1 99</span><br /></pre><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><em>I checked that there were no application processes running. It looks like a huge memory leak in the operating system. How can I get my memory back?<br />--RAMless in Ripon</em> </span></span><br /></p><p><strong><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="color:#dc2300;">Update</span></span></span></strong></p><p><strong style="font-weight: normal;"><span style=""><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="color:#dc2300;">This remains one of the most frequently asked questions of all time. The<br />original answer is still true for many Unix variants. However while<br />writing his book on Solaris Internals, Richard McDougall worked out<br />how to fix Solaris to make it work better, and to make this aparrent<br />problem go away. The result was one of the most significant<br />performance improvements in Solaris 8, but the first edition of his<br />book was written before Solaris 8 came out, so doesn't describe the<br />fix! </span></span></span></span></strong><br /></p><p><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;"><strong>The short answer</strong><br /><br />Launch your application again. Notice that it starts up more quickly than it did the first time, and with less disk activity. The application code and its data files are still<br />in memory, even though they are not active. The memory they occupy is<br />not "free." If you restart the same application it finds<br />the pages that are already in memory. The pages are attached to the<br />inode cache entries for the files. If you start a different<br />application, and there is insufficient free memory, the kernel will<br />scan for pages that have not been touched for a long time, and "free"<br />them. Once you quit the first application, the memory it occupies is<br />not being touched, so it will be freed quickly for use by other<br />applications. </span></span><br /></p><p><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">In 1988, Sun introduced this feature in SunOS 4.0. It still applies to<br />all versions of Solaris 1 and 2. The kernel is trying to avoid disk<br />reads by caching as many files as possible in memory. Attaching to a<br />page in memory is around 1,000 times faster than reading it in from<br />disk. The kernel figures that you paid good money for all of that<br />RAM, so it will try to make good use of it by retaining files you<br />might need. </span></span><br /></p><p><span style="color:#dc2300;"><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">Since Solaris 8, the memory in the file cache is actually also on the free<br />list, so you do see vmstat free memory reduce when you quit a<br />program. You also should expect large amounts of file I/O to cause<br />high scan rates on older Solaris releases, and for there to be no<br />scanning at all on Solaris 8 systems. If Solaris 8 scans at all, then<br />it has truly run out of memory and is overloaded. </span></span></span><br /></p><p><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">By contrast, Memory leaks appear as a shortage of swap space after the<br />misbehaving program runs for a while. You will probably find a<br />process that has a larger than expected size. You should restart the<br />program to free up the swap space, and check it with a debugger that<br />offers a leak-finding feature (<span style="color:#dc2300;">run it with the libumem version of the malloc library that instruments memory leaks</span>).</span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><strong>The long (and technical) answer</strong><br /><br />To understand how Sun's operating systems handle memory, I will explain how the inode cache works, how the buffer cache fits into the picture, and how the life<br />cycle of a typical page evolves as the system uses it for several<br />different purposes. </span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><strong>The inode cache and file data caching</strong><br /><br />Whenever you access a file, the kernel needs to know the size, the access permissions,<br />the date stamps and the locations of the data blocks on disk.<br />Traditionally, this information is known as the inode for the file.<br />There are many filesystem types. For simplicity I will assume we are<br />only interested in the Unix filesystem (UFS) on a local disk. Each<br />filesystem type has its own inode cache. </span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">The filesystem stores inodes on the disk; the inode must be read into<br />memory whenever an operation is performed on an entity in the<br />filesystem. The number of inodes read per second is reported as<br /><code><span style="font-family:courier;">iget/s</span></code> by the <code><span style="font-family:courier;">sar<br />-a</span></code> command. The inode read from disk is cached in case<br />it is needed again, and the number of inodes that the system will<br />cache is influenced by a kernel parameter called <em>ufs_ninode</em>.<br />The kernel keeps inodes on a linked list, rather than in a fixed-size<br />table. </span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">As I mention each command I will show you what the output looks like. In<br />my case I'm collecting <code><span style="font-family:courier;">sar</span></code><br />data automatically using <code><span style="font-family:courier;">cron</span></code>.<br /><code><span style="font-family:courier;">sar</span></code>, which defaults to<br />reading the stored data for today. If you have no stored data,<br />specify a time interval and <code><span style="font-family:courier;">sar</span></code><br />will show you current activity. </span></span><br /></p><pre><span style="font-family:courier;"><span style="font-size:85%;">% sar -a</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">SunOS hostname 5.4 Generic_101945-32 sun4c    09/18/95</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">00:00:01  iget/s namei/s dirbk/s</span></span><br /><span style="font-family:courier;"><span style="font-size:85%;">01:00:01       4       6       0</span></span><br /></pre><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">All reads or writes to UFS files occur by paging from the filesystem. All<br />pages that are part of the file and are in memory will be attached to<br />the inode cache entry for that file. When a file is not in use, its<br />data is cached in memory, using an inactive inode cache entry. When<br />the kernel reuses an inactive inode cache entry that has pages<br />attached, it puts the pages on the free list; this case is shown by<br /><code><span style="font-family:courier;">sar -g</span></code> as <code><span style="font-family:courier;">%ufs_ipf</span></code>.<br />This number is the percentage of UFS inodes that were overwritten in<br />the inode cache by <code><span style="font-family:courier;">iget</span></code> and<br />that had reusable pages associated with them. The kernel flushes the<br />pages, and updates on disk any modified pages. Thus, this %ufs_ipf<br />number is the percentage of igets with page flushes. Any non-zero<br />values of %ufs_ipf reported by <code><span style="font-family:courier;">sar -g</span></code><br />indicate that the inode cache is too small for the current workload. </span></span><br /></p><pre><span style="font-family:courier;"><span style="font-size:85%;">% sar -g</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">SunOS hostname 5.4 Generic_101945-32 sun4c    09/18/95</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">00:00:01  pgout/s ppgout/s pgfree/s pgscan/s %ufs_ipf</span></span><br /><span style="font-family:courier;"><span style="font-size:85%;">01:00:01     0.02     0.02     0.08     0.12     0.00</span></span><br /></pre><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">For SunOS 4 and releases up to Solaris 2.3, the number of inodes that the<br />kernel will keep in the inode cache is set by the kernel variable<br /><em>ufs_ninode</em>. To simplify: When a file is opened, an inactive<br />inode will be reused from the cache if the cache is full; when an<br />inode becomes inactive, it is discarded if the cache is over-full. If<br />the cache limit has not been reached then an inactive inode is placed<br />at the back of the reuse list and invalid inodes (inodes for files<br />that longer exist) are placed at the front for immediate reuse. It is<br />entirely possible for the number of open files in the system to cause<br />the number of active inodes to exceed <em>ufs_ninode</em>; raising<br /><em>ufs_ninode</em> allows more inactive inodes to be cached in case<br />they are needed again. </span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">Solaris 2.4 uses a more clever inode cache algorithm. The kernel maintains a<br />reuse list of blank inodes for instant use. The number of active<br />inodes is no longer constrained, and the number of idle inodes<br />(inactive but cached in case they are needed again) is kept between<br /><em>ufs_ninode</em> and 75 percent of <em>ufs_ninode</em> by a new<br />kernel thread that scavenges the inodes to free them and maintains<br />entries on the reuse list. If you use <code><span style="font-family:courier;">sar<br />-v</span></code> to look at the inode cache, you may see a larger<br />number of existing inodes than the reported "size." </span></span><br /></p><pre><span style="font-family:courier;"><span style="font-size:85%;">% sar -v</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">SunOS hostname 5.4 Generic_101945-32 sun4c    09/18/95</span></span><br /><br /><span style="font-family:courier;"><span style="font-size:85%;">00:00:01  proc-sz    ov  inod-sz    ov  file-sz    ov   lock-sz</span></span><br /><span style="font-family:courier;"><span style="font-size:85%;">01:00:01   66/506     0 2108/2108    0  353/353     0    0/0   </span></span><br /></pre><p><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;"><strong>Buffer cache</strong><br /><br />The buffer cache is used to cache filesystem<br />data in SVR3 and BSD Unix. In SunOS 4, generic SVR4, and Solaris 2,<br />it is used to cache inode, indirect block, and cylinder group blocks<br />only. Although this change was introduced in 1988, many people still<br />incorrectly think the buffer cache is used to hold file data. Inodes<br />are read from disk to the buffer cache in 8-kilobyte blocks, then the<br />individual inodes are read from the buffer cache into the inode<br />cache. </span></span><br /></p><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><strong>Life cycle of a typical physical memory page</strong><br /><br />This section provides additional insight into the way memory is used. The sequence<br />described is an example of some common uses of pages; many other<br />possibilities exist. </span></span><br /> </p><dl><dt style="margin-bottom: 0.2in;"><a name="Step 1"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">1. Initialization -- A page is born </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">When the system boots, it forms all free memory into pages, and allocates<br />a kernel data structure to hold the state of every page in the<br />system. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 2"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">2. Free -- An untouched virgin page </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">All the memory is put onto the free list to start with. At this stage the<br />content of the page is undefined. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 3"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">3. ZFOD -- Joining an uninitialized data segment </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">When a program accesses data that is preset to zero for the very first<br />time, a minor page fault occurs and a Zero Fill On Demand (ZFOD)<br />operation takes place. The page is taken from the free list,<br />block-cleared to contain all zeroes, and added to the list of<br />anonymous pages for the uninitialized data segment. The program then<br />reads and writes data to the page. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 4"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">4. Scanned -- The pagedaemon awakes </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">When the free list gets below a certain size, the pagedaemon starts to<br />look for memory pages to steal from processes. It looks at all pages<br />in physical memory order; when it gets to the page, the page is<br />synchronized with the memory management unit (MMU) and a reference<br />bit is cleared. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 5"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">5. Waiting -- Is the program really using this page right now? </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">There is a delay that varies depending upon how quickly the pagedaemon<br />scans through memory. If the program references the page during this<br />period, the MMU reference bit is set. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 6"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">6. Pageout Time -- Saving the contents </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">The pageout daemon returns and checks the MMU reference bit to find that<br />the program has not used the page so it can be stolen for reuse. The<br />pagedaemon checks to see if anything had been written to the page;<br />if it contains no data, a page-out occurs. The page is moved to the<br />pageout queue and marked as I/O pending. The swapfs code clusters<br />the page together with other pages on the queue and writes the<br />cluster to the swap space. The page is then free and is put on the<br />free list again. It remembers that it still contains the program<br />data. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 7"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">7. Reclaim -- Give me back my page! </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">Belatedly, the program tries to read the page and takes a page fault. If the<br />page had been reused by someone else in the meantime, a major fault<br />would occur and the data would be read from the swap space into a<br />new page taken from the free list. In this case, the page is still<br />waiting to be reused, so a minor fault occurs, and the page is moved<br />back from the free list to the program's data segment. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 8"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">8. Program Exit -- Free again </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">The program finishes running and exits. The data segments are private to<br />that particular instance of the program (unlike the shared-code<br />segments), so all the pages in the data segment are marked as<br />undefined and put onto the free list. This is the same state as <a href="http://www.blogger.com/post-edit.g?blogID=7434008&postID=113077969542636161#Step%202">Step<br />2</a>. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 9"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">9. Page-in -- A shared code segment </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">A page fault occurs in the code segment of a window system shared library.<br />The page is taken off the free list, and a read from the filesystem<br />is scheduled to get the code. The process that caused the page fault<br />sleeps until the data arrives. The page is attached to the inode of<br />the file, and the segments reference the inode. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 10"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">10. Attach -- A popular page </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">Another process using the same shared-library page faults in the same place.<br />It discovers that the page is already in memory and attaches to the<br />page, increasing its inode reference count by one. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"><a name="Step 11"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">11. COW -- Making a private copy </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">If one of the processes sharing the page tries to write to it, a<br />copy-on-write (COW) page fault occurs. Another page is grabbed from<br />the free list, and a copy of the original is made. This new page<br />becomes part of a privately mapped segment backed by anonymous<br />storage (swap space) so it can be changed, but the original page is<br />unchanged and can still be shared. Shared libraries contain jump<br />tables in the code that are patched, using COW as part of the<br />dynamic linking process. </span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 12"></a><span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">12. File Cache -- Not free </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">The entire window system exits, and both processes go away. This time<br />the page stays in use, attached to the inode of the shared library<br />file. The inode is now inactive but will stay in the inode cache<br />until it is reused, and the pages act as a file cache in case the<br />user is about to restart the window system again. <span style="color:#dc2300;">The<br />change made in Solaris 8 was that the file cache is the tail of the<br />free list, and any file cache page can be reused immediately for<br />something else without needing to be scanned first.</span></span></span><br /></dd><dt style="margin-bottom: 0.2in;"> <a name="Step 13"></a><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">13.<em> fsflush</em> -- Flushed by the sync </span></span><br /></dt><dd style="margin-bottom: 0.2in;"> <span style="font-family:verdana, arial, geneva, sans-serif;"><span style="font-size:85%;">Every 30 seconds all the pages in the system are examined in physical page<br />order to see which ones contain modified data and are attached to a<br />vnode. The details differ between SunOS 4 and Solaris 2, but<br />essentially any modified pages will be written back to the<br />filesystem, and the pages will be marked as clean. </span></span><br /><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;">This example sequence can continue from <a href="http://www.blogger.com/post-edit.g?blogID=7434008&postID=113077969542636161#Step%204">Step 4</a> or<br /><a href="http://www.blogger.com/post-edit.g?blogID=7434008&amp;postID=113077969542636161#Step%209">Step 9</a> with minor variations. The <em>fsflush</em><br />process occurs every 30 seconds by default for all pages, and<br />whenever the free list size drops below a certain value, the<br />pagedaemon scanner wakes up and reclaims some pages. <span style="color:#dc2300;">A<br />recent change in Solaris 10, backported to Solaris 8 and 9 patches,<br />makes fsflush run much more efficiently on machines with very large<br />amounts of memory. However, if you see fsflush using an excessive<br />amount of CPU time you should increase “autoup” in /etc/system<br />from its default of 30s, and you will see fsflush usage reduce<br />proportionately.</span></span></span><br /></dd></dl><p><span style="font-size:85%;"><span style="font-family:verdana, arial, geneva, sans-serif;"><strong>Now you know</strong><br /><br />I have seen this missing-memory question<br />asked about once a month since 1988! Perhaps the manual page for<br /><em>vmstat</em> should include a better explanation of what the<br />values are measuring. This answer is based on some passages from my<br />book <em><a href="http://www.amazon.com/gp/product/0130952494/002-4502333-9850410">Sun Performance and Tuning</a></em>. The book explains in detail how the<br />memory algorithms work and how to tune them. <span style="color: rgb(255, 0, 0);">However the book doesn't cover the changes made in Solaris 8.</span></span></span><br /></p>