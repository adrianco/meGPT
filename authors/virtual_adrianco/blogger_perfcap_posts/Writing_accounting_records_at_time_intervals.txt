Title: Writing accounting records at time intervals
URL: https://perfcap.blogspot.com/2005/04/writing-accounting-records-at-time.html

A major new feature of the exacct system is the ability to get an accounting record logged without terminating the process. There are two forms of this, for tasks you can get the record to dump the delta since the last record was logged. Somehow the task remembers the data each time it cuts a record so it can do the differencing. This seems to be too much overhead at the process level, so the other option is to cut a record that logs the same data as if the process had just exited, and this option is available for both tasks and processes.<br /><br />The command that causes a record to be written is "wracct" and it takes a list of process or task id's and makes a system call to cause the record to be written. You have to be root to do this. The wracct command line syntax is a pain if you want to get it to dump multiple processes, as shown in this example from the manpage:<br /><pre><br /># /usr/sbin/wracct -i "`pgrep sendmail`" process<br /></pre><br />I want to make every process cut a record, and if you attempt to do this with wracct you need to form a list of every process id on the system. I tried to do this by listing all the entries in the /proc filesystem, but if any of the pid's exit before wracct gets to them it gets an error and quits. This is stupid, because if a process has exited, it has already cut an accounting record! The wracct command should have a "-a" option that writes all records and ignores errors.<br /><br />I modified the exdump command to have a "-w" option that loops over all processes and forces an accounting record to be written before it reads the accounting file. If you aren't root, it has no effect. The code looks like this:<br /><br /><pre><br /> if (wflag) {<br />  DIR *dirp;<br />  struct dirent *dp;<br /><br />  dirp = opendir("/proc");<br />              do {<br />                 if ((dp = readdir(dirp)) != NULL)<br />     (void) wracct(P_PID, atoi(dp->d_name), EW_PARTIAL);<br />              } while (dp != NULL);<br />               (void) closedir(dirp);<br />                <br /> }<br /></pre><br /><br />The next step is a bit more complex. Both for flow accounting and interval process accounting, I need code that remembers previous records and matches them with subsequent ones so that they can be accumulated (flows) or differenced (process intervals).